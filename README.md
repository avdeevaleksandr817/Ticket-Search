# Ticket-Search
# Домашнее задание к занятию «Интерфейсы для организации малой связности. Обобщённое программирование (Generics)»
# Задание 1. Поиск билетов (обязательное к выполнению)
 Вы работаете в сервисе по продаже авиабилетов онлайн.

![image](https://user-images.githubusercontent.com/97477540/207928717-46713cb2-8634-4ff4-9142-0244cb653944.png)

### Что вам нужно сделать:

Спроектируйте класс для информации о билете.
Реализуйте репозиторий для хранения информации о билетах: добавить, удалить, получить набор билетов.
Реализуйте менеджера поиска по аэропорту вылета и аэропорту прилёта, даты не учитывайте.
Информация о билете
Класс информации о билете — это data-класс, который должен содержать:

* ID.
* Стоимость, для упрощения будем считать стоимость единой для всех продавцов.
* Аэропорт вылета, вы можете использовать IATA-коды.
* Аэропорт прилёта, вы можете использовать IATA-коды.
* Время в пути в минутах.
* Других данных не нужно.

Этот класс должен реализовывать интерфейс Comparable<...> так, чтобы по умолчанию сортировка происходила по цене, самый дешёвый — самый первый. Для этого шапка вашего дата-класса должна выглядеть как-то так:

public class Ticket implements Comparable<Ticket> {
После чего идея подсветит вам её красным, нажмите на подсказку и выберите «Implement methods» — «Реализовать методы». Идея сама сгенерирует заглушку для нужного метода из этого интерфейса, которая всегда возвращает 0. Вам надо переписать тело сгенерированного метода, чтобы если билет, у которого вызвали метод compareTo, стоит дешевле, чем тот, который передали через параметр, то возвращалось бы число меньше нуля. Если же билет, наоборот, дороже, то число больше нуля, а если стоимость одинакова, то 0. Дав верную реализацию этому методу, вы научите Java сравнивать объекты этого класса.

### Репозиторий
Репозиторий для хранения билетов ничем не отличается от тех репозиториев, что мы проходили раньше.

### Менеджер
В менеджере методов findAll должен претерпеть некоторые изменения — он должен принимать два параметра:

from — аэропорта вылета,
to — аэропорт прилёта.
Значит, в результате поиска возвращается массив только с теми билетами, что соответствуют условиям поиска. Методы поиска вы уже делать умеете.

Кроме того, результаты должны быть отсортированы по цене от меньшей к большей.

### Автотесты
Напишите автотесты на поиск, удостоверившись, что он удовлетворяет условиям задачи. Количество тестов и тестируемые сценарии мы оставляем на ваше усмотрение.

Итого: у вас должен быть репозиторий на GitHub, в котором расположен ваш Java-код и автотесты к нему, GitHub Actions и т. д. — всё как обычно.

Отправьте на проверку ссылку на репозиторий GitHub с вашим проектом.

# Задание 2*. Самый быстрый (необязательная задача)
Иногда необходима сортировка не только по цене, но и, например, по времени — люди хотят найти самый быстрый перелёт.

Естественно, ваш сервис идёт навстречу пожеланиям клиентов и решает добавить такую возможность.

Но как мы это сделаем, ведь наши билеты уже сортируются по цене.

### Comparator
Помимо интерфейса Comparable, который определяет порядок сортировки объектов данного класса по умолчанию, у нас есть интерфейс Comparator, который позволяет создавать объекты, определяющие порядок сортировки других объектов.

Как это выглядит, мы покажем на примере сортировки по цене по возрастанию — аналог, который реализован вами в первой задаче:

* public class TicketByPriceAscComparator implements Comparator<Ticket> {
*  public int compare(Ticket o1, Ticket o2) {
*    return o1.getPrice() - o2.getPrice();
*  }
}
Обратите внимание: это отдельный специальный класс, который умеет сравнивать два объекта типа «Билет».

Логика интерпретации возвращаемого из метода compare значения аналогична логике compareTo.

В отдельной ветке fast того же репозитория улучшите сервис, создав метод findAll(String from, String to, Comparator<Ticket> comparator).

Этот метод делает всё то же самое, что и обычный findAll из первой задачи, но сортирует не методом Arrays.sort(result), а Arrays.sort(result, comparator).

Таким образом, вы сможете передавать в этот метод объект любого класса, реализующего интерфейс Comparator<Ticket>.

Итого: у вас должен быть репозиторий на GitHub, в котором в отдельной ветке расположен ваш компаратор, сервис с новыми методами и автотесты к сервису.

Если автотесты в ветке проходят — делаете Pull Request на слияние в основную ветку. Сливать не нужно.
